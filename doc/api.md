# Web3 Monitoring Agent API

Table of Contents
=================

   * [Web3 Monitoring Agent API](#web3-monitoring-agent-api)
   * [Table of Contents](#table-of-contents)
      * [Events](#events)
         * [Registering Events](#registering-events)
            * [REST](#rest)
            * [Hard Coded Configuration](#hard-coded-configuration)
         * [Un-Registering Events](#un-registering-events)
            * [REST](#rest-1)
         * [Listing Registered Events](#listing-registered-events)
            * [REST](#rest-2)
      * [Smart Contract Views](#smart-contract-views)
         * [Registering Views Calls](#registering-views-calls)
            * [REST](#rest-3)
            * [Hard Coded Configuration](#hard-coded-configuration-1)
         * [Un-Registering Views](#un-registering-views)
            * [REST](#rest-4)
         * [Listing Registered Views](#listing-registered-views)
            * [REST](#rest-5)
      * [Transactions](#transactions)
         * [Registering a Transaction Monitor](#registering-a-transaction-monitor)
            * [REST](#rest-6)
         * [Un-Registering a Transaction Monitor](#un-registering-a-transaction-monitor)
            * [REST](#rest-7)
      * [Broadcast Messages Format](#broadcast-messages-format)
         * [Contract Events](#contract-events)
         * [Block Events](#block-events)
         * [Transaction Events](#transaction-events)
            * [Contract Creation Transaction](#contract-creation-transaction)
            * [Transaction Event Statuses](#transaction-event-statuses)



## Events 

### Registering Events

#### REST

The server exposes a REST api that can be used to register events that should be subscribed to / broadcast.

-   **URL:** `/api/rest/v1/event-filter`    
-   **Method:** `POST`
-   **Headers:**  

| Key | Value |
| -------- | -------- |
| content-type | application/json |

-   **URL Params:** `N/A`
-   **Body:**

```json
{
	"id": "event-identifier",
	"contractAddress": "0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2",
	"eventSpecification": {
		"eventName": "TestEvent",
		"indexedParameterDefinitions": [
		  {"position": 0, "type": "UINT256"},
		  {"position": 1, "type": "ADDRESS"}],
		"nonIndexedParameterDefinitions": [
		  {"position": 2, "type": "BYTES32"},
		  {"position": 3, "type": "STRING"}] },
	"correlationIdStrategy": {
		"type": "NON_INDEXED_PARAMETER",
		"parameterIndex": 0 }
}
```
| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| id | String | no | Autogenerated | A unique identifier for the event. |
| contractAddress | String | yes |  | The address of the smart contract that the address will be emitted from. |
| eventSpecification | json | yes |  | The event specification |
| correlationIdStrategy | json | no | null | Define a correlation id for the event (only used with the Kafka broadcaster).  See the advanced section for details. |

**eventSpecification**:

| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| eventName | String | yes | | The event name within the smart contract |
| indexedParameterTypes | String array | no | null | The array of indexed parameter types for the event. |
| nonIndexedParameterTypes | String array | no | null | The array of non-indexed parameter types for the event. |

**parameterDefinition**:

| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| position | Number | yes | | The zero indexed position of the parameter within the event specification |
| type | String | yes | | The type of the event parameter. |

Currently supported parameter types: `UINT8-256`, `INT8-256`, `ADDRESS`, `BYTES1-32`, `STRING`, `BOOL`.

Dynamically sized arrays are also supported by prefixing the type with `[]`

**correlationIdStrategy**:

| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| type | String | yes | | The correlation id strategy type. |
| parameterIndex | Number | yes | | The parameter index to use within the correlation strategy. |

-   **Success Response:**
    -   **Code:** 200  
        **Content:**

```json
{
    "id": "event-identifier"
}
```

#### Hard Coded Configuration
Static events can be configured within the application.yml file of Eventeum.

```yaml
eventFilters:
  - id: RequestCreated
    contractAddress: ${CONTRACT_ADDRESS:0x4aecf261541f168bb3ca65fa8ff5012498aac3b8}
    eventSpecification:
      eventName: RequestCreated
      indexedParameterDefinitions:
        - position: 0
          type: BYTES32
        - position: 1
          type: ADDRESS
      nonIndexedParameterDefinitions:
        - position: 2
          type: BYTES32
    correlationId:
      type: NON_INDEXED_PARAMETER
      index: 0
```

### Un-Registering Events

#### REST

-   **URL:** `/api/rest/v1/event-filter/{event-id}`    
-   **Method:** `DELETE`
-   **Headers:**  `N/A`
-   **URL Params:** `N/A`
-   **Body:** `N/A`

-   **Success Response:**
    -   **Code:** 200
        **Content:** `N/A`

### Listing Registered Events

#### REST

-   **URL:** `/api/rest/v1/event-filter`    
-   **Method:** `GET`
-   **Headers:**  

| Key | Value |
| -------- | -------- |
| accept | application/json |

-   **URL Params:** `N/A`

-   **Response:** List of contract event filters:
```json
[{
	"id": "event-identifier-1",
	"contractAddress": "0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2",
	"eventSpecification": {
		"eventName": "TestEvent",
		"indexedParameterDefinitions": [
		  {"position": 0, "type": "UINT256"},
		  {"position": 1, "type": "ADDRESS"}],
		"nonIndexedParameterDefinitions": [
		  {"position": 2, "type": "BYTES32"},
		  {"position": 3, "type": "STRING"}] },
	"correlationIdStrategy": {
		"type": "NON_INDEXED_PARAMETER",
		"parameterIndex": 0 }
},
....
{
	"id": "event-identifier-N",
	"contractAddress": "0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2",
	"eventSpecification": {
		"eventName": "TestEvent",
		"indexedParameterDefinitions": [
		  {"position": 0, "type": "UINT256"},
		  {"position": 1, "type": "ADDRESS"}],
		"nonIndexedParameterDefinitions": [
		  {"position": 2, "type": "BYTES32"},
		  {"position": 3, "type": "STRING"}] },
	"correlationIdStrategy": {
		"type": "NON_INDEXED_PARAMETER",
		"parameterIndex": 0 }
}
]
```

## Smart Contract Views 

This API section allows to users to subscribe/unsubscribe/fetch information from Smart Contracts via contract calls to any public method.
Because Solidity [generates getter functions](https://www.bitdegree.org/learn/solidity-functions#getter-methods) for the public variables of the Smart Contracts, this functionality allows to fetch and track the value of public variables.

### Registering Views Calls

#### REST

The server exposes a REST api that can be used to register views that should be subscribed to / broadcast.

-   **URL:** `/api/rest/v1/view-filter`    
-   **Method:** `POST`
-   **Headers:**  

| Key | Value |
| -------- | -------- |
| content-type | application/json |

-   **URL Params:** `N/A`
-   **Body:**

```json
{
	"id": "view-identifier",
	"contractAddress": "0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2",
	"contractName": "MySmartContract",
	"methodSpecification": {
		"methodName": "myPublicMethod",
		"inputParameterDefinitions": [
		  {"position": 0, "type": "UINT256", "name": "foo", "value":  "0"},
		  {"position": 1, "type": "ADDRESS", "name": "bar", "value": "0x0"}],
		"outputParameterDefinitions": [
		  {"position": 0, "type": "BYTES32", "name": "result"}]
    },
    "pollingStrategy": {
        "blockInterval": 1
    }
}
```
| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| id | String | no | Autogenerated | A unique identifier for the view. |
| contractAddress | String | yes |  | The address of the smart contract exposing the public method or view. |
| contractName | String | yes |  | The name of the smart contract |
| methodSpecification | json | yes |  | The method specification |
| pollingStrategy | json | no | null | Define the polling strategy for querying the Smart Contract. It allows to specify the frequency of the polling (in each block confirmed, each 5 blocks, etc.) |

**methodSpecification**:

| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| methodName | String | yes | | The method name within the smart contract |
| inputParameterDefinitions | String array | no | null | The array of parameters to pass to the method. |
| outputParameterDefinitions | String array | no | null | The array of parameters returned after calling the method. |

**parameterDefinition**:

| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| position | Number | yes | | The zero indexed position of the parameter within the method specification |
| type | String | yes | | The type of the method parameter. |
| name | String | no | | The name of the method parameter. |
| value | String | yes | | The value passed. |

Currently supported parameter types: `UINT8-256`, `INT8-256`, `ADDRESS`, `BYTES1-32`, `STRING`, `BOOL`.

**pollingStrategy**:

| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| blockInterval | Number | No | 1 | Polling frequency in blocks. If 1, the system will execute the contract call for each block. |

-   **Success Response:**
    -   **Code:** 200  
        **Content:**

```json
{
    "id": "view-identifier"
}
```

#### Hard Coded Configuration

Static views can be configured within the application.yml file of Eventeum.

```yaml
viewFilters:
  - id: Governance-Foo
    contractAddress: ${CONTRACT_ADDRESS:0x4aecf261541f168bb3ca65fa8ff5012498aac3b8}
    contractName: MySmartContract
    methodSpecification:
      methodName: RequestCreated
      inputParameterDefinitions:
        - position: 0
          type: UINT256
          name: foo
          value: 0
        - position: 1
          type: ADDRESS
      outputParameterDefinitions:
        - position: 0
          type: ADDRESS
          name: result
          value: 0x1
    pollingStrategy:
      blockInterval: 1
```

### Un-Registering Views

#### REST

-   **URL:** `/api/rest/v1/view-filter/{view-id}`    
-   **Method:** `DELETE`
-   **Headers:**  `N/A`
-   **URL Params:** `N/A`
-   **Body:** `N/A`

-   **Success Response:**
    -   **Code:** 200
        **Content:** `N/A`

### Listing Registered Views

#### REST

-   **URL:** `/api/rest/v1/view-filter`    
-   **Method:** `GET`
-   **Headers:**  

| Key | Value |
| -------- | -------- |
| accept | application/json |

-   **URL Params:** `N/A`

-   **Response:** List of contract view filters:
```json
[
    {
        "id": "view-identifier-1",
        "contractAddress": "0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2",
    	"contractName": "MySmartContract",
        "methodSpecification": {
            "methodName": "myPublicMethod",
            "inputParameterDefinitions": [
              {"position": 0, "type": "UINT256", "name": "foo", "value":  "0"},
              {"position": 1, "type": "ADDRESS", "name": "bar", "value": "0x0"}],
            "outputParameterDefinitions": [
              {"position": 0, "type": "BYTES32", "name": "result"}]
        },
        "pollingStrategy": {
            "blockInterval": 1
        }
    },
....
    {
    	"id": "view-identifier-N",
    	"contractAddress": "0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2",
	    "contractName": "MySmartContractN",
    	"methodSpecification": {
    		"methodName": "myPublicMethod2",
    		"inputParameterDefinitions": [
    		  {"position": 0, "type": "UINT256", "name": "foo", "value":  "0"}
    		"outputParameterDefinitions": [
    		  {"position": 0, "type": "BYTES32", "name": "result"}]
        },
        "pollingStrategy": {
            "blockInterval": 1
        }
    }
]
```

### Get one Registered View by Id

#### REST

-   **URL:** `/api/rest/v1/view-filter/{id}`    
-   **Method:** `GET`
-   **Headers:**  

| Key | Value |
| -------- | -------- |
| accept | application/json |

-   **URL Params:** `N/A`

-   **Response:** View Filter:
```json
    {
        "id": "view-identifier-1",
        "contractAddress": "0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2",
    	"contractName": "MySmartContract",
        "methodSpecification": {
            "methodName": "myPublicMethod",
            "inputParameterDefinitions": [
              {"position": 0, "type": "UINT256", "name": "foo", "value":  "0"},
              {"position": 1, "type": "ADDRESS", "name": "bar", "value": "0x0"}],
            "outputParameterDefinitions": [
              {"position": 0, "type": "BYTES32", "name": "result"}]
        },
        "pollingStrategy": {
            "blockInterval": 1
        }
    }
```

## Transactions 

### Registering a Transaction Monitor

It supports monitoring and broadcasting transactions. The matching criteria can be:

- HASH: Monitor a single transaction hash. The monitoring will be removed once is notified.
- FROM_ADDRESS: Monitor all transactions that are sent from a specific address.
- TO_ADDRESS: Monitor all transactions that are received for a specific address.


Besides on that, it can monitor the transaction for specific statuses: 

- FAILED: It will notify if the transaction has failed
- CONFIRMED: It will notify if the transaction is confirmed.
- UNCONFIRMED: In case the network is configured to wait for a certain number of confirmations, this will notify when is mined and not confirmed.

#### REST

To register a transaction monitor, use the below REST endpoint:

-   **URL:** `/api/rest/v1/transaction?identifier=<txHash>&nodeName=<nodeName>`
-   **Method:** `POST`
-   **Headers:**  `N/A`
-   **URL Params:** `N/A`
    - identifier - The transaction hash to monitor
    - nodeName - The node name that should be monitored
-   **Body:**

An example with type `HASH`:

```json
{
	"type": "HASH",
	"transactionIdentifierValue": "0x2e8e0f98be22aa1251584e23f792d43c634744340eb274473e01a48db939f94d",
	"nodeName": "defaultNetwork",
	"statuses": ["FAIlED", "CONFIRMATION"]
}
```


Example filtering by `FROM_ADDRES`, this will notify when a transactions fails with origin the address specified in the field `transactionIdentifierValue`

```json
{
	"type": "FROM_ADDRESS" ,
	"transactionIdentifierValue": "0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2",
	"nodeName": "defaultNetwork",
	"statuses": ["FAIlED"]
}
```


| Name | Type | Mandatory | Default | Description |
| -------- | -------- | -------- | -------- | -------- |
| type | String | yes | | The type of the filter you want to create: `HASH`, `FROM_ADDRESS`, `TO_ADDRESS` |
| transactionIdentifierValue | String | yes |  | The value associated with the type. It should be the tx hash for `HASH` and the address of the contract in the other cases. |
| nodeName | String | yes | default | The identifier of the node you want to listen the transaction |
| statuses | List | no | ['FAILED', 'CONFIRMED'] | It will specify the statuses you want to be notified. The default is failed and confirmed transactions. The options are: `FAILED`, `CONFIRMED`, `UNCONFIRMED`, `INVALIDATED` |


-   **Success Response:**
    -   **Code:** 200
        **Content:**

```json
{
    "id": "transaction-monitor-identifier"
}
```

### Un-Registering a Transaction Monitor

#### REST

-   **URL:** `/api/rest/v1/transaction/{monitor-id}`
-   **Method:** `DELETE`
-   **Headers:**  `N/A`
-   **URL Params:** `N/A`
-   **Body:** `N/A`

-   **Success Response:**
    -   **Code:** 200  
        **Content:** `N/A`

## Broadcast Messages Format

###  Contract Events
When a subscribed event is emitted, a JSON message is broadcast to the configured kafka topic (w3m-contract-events by default), with the following format:

```json
{
	"id":"unique-event-id",
	"type":"CONTRACT_EVENT",
	"details":{
		"name":"DummyEvent",
		"filterId":"63da468c-cec6-49aa-bea4-eeba64fb1df4",
		"indexedParameters":[{"type":"bytes32","value":"BytesValue"},
			{"type":"address","value":"0x00a329c0648769a73afac7f9381e08fb43dbea72"}],
		"nonIndexedParameters":[{"type":"uint256","value":10},
			{"type":"string","value":"StringValue"}],
		"transactionHash":"0xe4fd0f095990ec471cdf40638336a73636d2e88fc1a240c20b45101b9cce9438",
		"logIndex":0,
		"blockNumber":258,
		"blockHash":"0x65d1956c2850677f75ec9adcd7b2cfab89e31ad1e7a5ba93b6fad11e6cd15e4a",
		"address":"0x9ec580fa364159a09ea15cd39505fc0a926d3a00",
		"status":"UNCONFIRMED",
		"eventSpecificationSignature":"0x46aca551d5bafd01d98f8cadeb9b50f1b3ee44c33007f2a13d969dab7e7cf2a8",
		"id":"unique-event-id"},
		"retries":0
}

```

### Block Events
When a new block is mined, a JSON message is broadcast to the configured kafka topic (w3m-block-events by default), with the following format:

```json
 {
 	"id":"0x79799054d1782eb4f246b3055b967557148f38344fbd7020febf7b2d44faa4f8",
	"type":"BLOCK",
	"details":{
		"number":257,
		"hash":"0x79799054d1782eb4f246b3055b967557148f38344fbd7020febf7b2d44faa4f8",
		"timestamp":12345678},
	"retries":0
}
```


### Transaction Events
When a new transaction that matches a transaction monitor is mined, a JSON message is broadcast to the configured kafka topic (w3m-transaction-events by default), with the following format:

```json
 {
 	"id":"0x1c0482642861779703a34f4539b3ba18a0fddfb16558f3be7157fdafcaf2c030",
	"type":"TRANSACTION",
	"details":{
		"hash":"0x1c0482642861779703a34f4539b3ba18a0fddfb16558f3be7157fdafcaf2c030",
		"nonce":"0xf",
		"blockHash":"0x6a68edf369ba4ddf93aa31cf5871ad51b5f7988a69f1ddf9ed09ead8b626db48",
		"blockNumber":"0x1e1",
		"transactionIndex":"0x0",
		"from":"0xf17f52151ebef6c7334fad080c5704d77216b732",
		"to":"0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef",
		"value":"0x16345785d8a0000",
		"nodeName":"default",
		"status":"CONFIRMED"},
	"retries":0
}
```

#### Contract Creation Transaction
If the transaction is a contract creation transaction, then the `contractAddress` value will be set to the address of the newly deployed smart contract.

#### Transaction Event Statuses

A broadcast transaction event can have the following statuses:

| Status | Description |
| -------- | -------- |
| UNCONFIRMED | Transaction has been mined and we're now waiting for the configured number of blocks |
| CONFIRMED | The configured number of blocks have been mined since the transaction has been mined |
| INVALIDATED | The blockchain has forked since the initially broadcast UNCONFIRMED transaction was broadcast |
| FAILED | The transaction has been mined but the tx execution failed |
